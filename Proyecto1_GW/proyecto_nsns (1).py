# -*- coding: utf-8 -*-
"""Proyecto_NSNS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DSaPJ3iled8ZSTcIWrVg4NTLFeYxCsAU

Grupo: Juan Gómez, Oscar López, Alvaro Robles, Tomás Rocha. Proyecto 1: Aplicaciones Computacionales.

# Plantillas desde SXS
Primero instalamos la libreria sxs `!pip install sxs -q`
"""

!pip install sxs -q

# Commented out IPython magic to ensure Python compatibility.
import sxs # import sxs
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import lagrange, CubicSpline, PchipInterpolator
# %config InlineBackend.figure_format = 'retina'

#@title Descargar los datos de las dos estrellas de neutrones

sxs_nsns_0001 = sxs.load("SXS:NSNS:0001")
w = sxs_nsns_0001.h

"""`w.metadata` los datos de los datos"""

print('tipo de objetos: '+w.metadata.object_types) #NSNS significa que estamos trabajando con dos estrellas de neutrones

t0 = w.metadata.reference_time # tiempo de referencia, al inicio hay "junk radiation", por lo que a partir de este tiempo se consider que los valores en los datos representan información de lo que se busca medir
print(f't0 = {t0}')

w.data # todos los multipolos, donde aparece un número complejo que es igual a la fase de cada multipolo

#@title Selección del multipolo a trabajar
ell, m = 2, 2  # seleccionar el multipolo en el modo que contiene mayor cantidad de información sobre el suceso.
i22 = w.index(ell, m) # seleccionar el indice del multipolo correspondiente
print(i22)
# guardar la onda 2 2 en w_2_2
w_2_2 = w[:, i22] #La información aquí contenida representa cómo cambia la amplitud y la fase de la estrella a lo largo del tiempo, número complejo

#@title Calculo de la fase de cada onda gravitacional
phi = np.angle(w_2_2) #Se calcula la fase de los valores medidos

fases = np.unwrap(-phi) # Se calcula la fase sin saltos de discontinuidad
fases_dif = fases[1::] - fases[:-1:] # Se calcula el valor de la diferencia de fases
(fases_dif<0).sum() #Se buscan los valores en que su diferencia sea menor que cero
max_value = np.where(fases_dif<0) #El valor máximo de la fase (el punto en que deje de ser positiva la diferencia de fases)
print(max_value[0][0])

paso = np.all(fases_dif == fases_dif[0]) #Revisar si el paso es constante, es decir, si los valores en el array de diferencias de fase son iguales o no
print(paso)

x_max = w_2_2.t[max_value[0][0]] # Se define el valor máximo en x
y_max = np.unwrap(-phi)[max_value[0][0]] # Se define el valor máximo en y

#@title Gráfica del movimiento descrito en los datos de las dos estrellas de neutrones
#Se describe el movimiento del multipolo 2,2 en una gráfica, a partir de ahora se trabajará con este multipolo
plt.figure()
plt.plot(w.t, np.real(w_2_2), label='Parte Real') #Las partes real e imaginaria representan la polarización de la onda.
plt.plot(w.t, np.imag(w_2_2), label='Parte Imaginaria') #w.t representa el tiempo guardado en w correspondiente a cada punto en w
plt.plot(w.t[max_value[0][0]], np.real(w_2_2)[max_value[0][0]], 'o', label = 'Punto máximo de la fase')
plt.plot(w.t[max_value[0][0]], np.imag(w_2_2)[max_value[0][0]], 'o', label = 'Punto máximo de la fase')
plt.legend()
#plt.plot(x_max, y_max, 'ro', label = 'Punto máximo de la fase')
#plt.legend()
plt.xlim(3000,3900)
plt.xlabel(r'$t$')
plt.ylabel(r'$h_{22}$')
plt.show()

print(w.t[max_value[0][0]], np.real(w_2_2)[max_value[0][0]])
print(w.t[max_value[0][0]], np.imag(w_2_2)[max_value[0][0]])

#@title Gráfica de la fase obtenida con los datos del sistema

#Gráfica de la fase de la onda, se saca el ángulo de la misma y se grafica comparado al tiempo
plt.plot(w_2_2.t, np.unwrap(-phi), 'k', label = 'Fase sin saltos de discontinuidad') #el np.unwrap se encarga de eliminar los saltos de la fase
plt.plot(w_2_2.t, -phi, 'b', label = 'Fase con saltos de discontinuidad')
plt.plot(x_max, y_max, 'ro', label = 'Punto máximo de la fase')
plt.legend()
plt.xlabel(r'$t/M$')
plt.xlim(t0, x_max + 100) #Se limita el eje x para visualizar el intervalo de itere( se agrega el 100 para visualizar mejor el punto máximo)
plt.ylabel(r'$\varphi$')
plt.show()

#Se crearon los valores t0 y el punto máximo de la fase para poder aplicar las distintas técnicas de interpolación
#sobre este intervalo es donde se va a interpolar, junto a una cantidad de pasos dentro del intervalo para tener un paso entre puntos constante.

#@title Creación de los intervalos a trabajar

n_p = 600 #Número de pasos dentro del intervalo a trabajar para interpolar
t_pol = np.linspace(t0, x_max, n_p)

# El rol que cumple el t_pol comparado al t_interp es que el primero se encarga de comparar los valores obtenidos de la interpolación
# y el t_interp es la sección de los datos obtenidos en donde estamos trabajando o sea desde t0 hasta max.

#Se encuentran los indices que cumplen la condición que necesita el intervalo para poder interpolar
indices = np.where((w_2_2.t >= t0) & (w_2_2.t <= x_max))

# Se crean dos arrays que contienen los datos de la medición pero en el intervalo que necesitamos
#Lo que se hace es reducirlos a los que realmente necesitamos para poder comparar los valores junto a la interpolación obtenida
t_interp = np.array(w_2_2.t[indices])
w_interp = np.array(np.unwrap(np.angle(w_2_2[indices]))) # Se crean los arrays pero los tiempo y fases directamente, se usa el unwrap sobre el ángulo para evitar los saltos de la fase entre -pi y pi
#ya que la función np.angle solo devuelve valores entre -pi y pi por lo que no representa realmente la continuidad de la fase hasta su punto máximo.

print(f'La cantidad de valores en los datos del multipolo w_2_2 es {len(w_2_2)}')
print(f'La cantidad de valores en los datos restringidos por t0 y x_max es {len(w_interp)}')
print(f'El mínimo en los datos está dado por el t0 = {t0} y el máximo por x_max = {x_max}')

#@title Cubic Spline natural

#Se crea el t_spline que contiene los valores de la primera interpolación
t_spline = CubicSpline(t_interp, w_interp, bc_type='natural')
#Este primer método de interpolación usa el 'natural' que significa que la segunda derivada es cero en la frontera.
#se grafican los valores obtenidos del método de interpolación junto a los puntos reales de la medición

plt.plot(t_interp, np.unwrap(-w_interp), 'g.', label = 'Puntos originales')
plt.plot(t_pol, np.unwrap(-t_spline(t_pol)), 'k', label = 'Spline')
plt.plot(x_max, y_max, 'v', label = 'Punto máximo de la fase')
plt.legend()
plt.show()

#@title Cubic Spline usando not-a-knot

#El t_spline_k representa el cubic spline pero con la condición de not a knot que es la condición que se usa en automatico
t_spline_k = CubicSpline(t_interp, w_interp)
#En not a knot la primera y la segunda derivada son continuas, es el mismo polinomio
plt.plot(t_interp, np.unwrap(-w_interp), 'r.', label = 'Puntos originales')
plt.plot(t_pol, np.unwrap(-t_spline_k(t_pol)), 'k', label = 'Spline not a knot')
plt.plot(x_max, y_max, 'v', label = 'Punto máximo de la fase')
plt.legend()
plt.show()

#Se hace negra la técnica de interpolación para apreciar de mejor forma la proximidad entre gráficas

#@title PchipInterpolator

t_pchip = PchipInterpolator(t_interp, w_interp)


plt.plot(t_interp, np.unwrap(-w_interp), 'y.', label = 'Puntos originales')
plt.plot(t_pol, np.unwrap(-t_pchip(t_pol)), 'k', label = 'Pchip')
plt.plot(x_max, y_max, 'v', label = 'Punto máximo de la fase')
plt.legend()
plt

#@title Lagrange interpolator
#Por la forma en que funciona lagrange, es mejor darle valores más pequeños y para que el código sea más eficiente se hizo una sección aparte solo para el funcionamiento de lagrange
num_points_lagrange = 10 # número de pasos en el que funciona lagrange (de 10 a 20)
indices_lagrange = np.linspace(1, len(t_interp) - 1, num_points_lagrange, dtype=int) #este indice se encarga de generar un array en donde cada valor es el indice que debe tomar los valores tiempo y fase
#se debe hacer un array distinto al que se tenía antes ya que los valores para lagrange son distintos, más pequeños por lo que es necesario hacer el proceso de nuevo.
t_lagrange_points = t_interp[indices_lagrange] # Valores de tiempo y fase para lagrange, siguiendo las iteraciones que dicta el indices para este método
w_lagrange_points = w_interp[indices_lagrange]


t_lagrange = lagrange(t_lagrange_points, w_lagrange_points)


#se grafican los resultados y poniendo un signo negativo para que la gráfica sea de mejor interpretación, se vea como un crecimiento a lo largo del tiempo.
plt.plot(t_interp, -w_interp, 'r.', label = 'Puntos originales') # Plot w_interp directly as it's already unwrapped
plt.plot(t_pol, -t_lagrange(t_pol), 'k', label = 'Lagrange') # Plot the interpolated values
plt.plot(x_max, y_max, 'v', label = 'Punto máximo de la fase')
plt.legend()
plt.show()

#@title Comparación de los métodos de interpolación
#Los métodos spline normal, spline not a knot practicamente se superponen


plt.plot(t_interp, np.unwrap(-w_interp), 'bo', label = 'Puntos originales')
plt.plot(t_pol, np.unwrap(-t_spline(t_pol)), 'g', label = 'Spline')
plt.plot(t_pol, np.unwrap(-t_spline_k(t_pol)), 'm', label = 'Spline not a knot')
plt.plot(t_pol, np.unwrap(-t_pchip(t_pol)), 'r', label = 'Pchip')
plt.plot(t_pol, -t_lagrange(t_pol), 'y', label = 'Lagrange')
plt.plot(x_max, y_max, 'kv', label = 'Punto máximo de la fase')
plt.legend()
plt.show()

#@title Grupos de Entrenamiento y de Prueba

t_train = t_interp[::300]
w_train = w_interp[::300]
t_test= t_interp[150::300]
w_test = w_interp[150::300]

print(len(t_train))
print(len(w_train))
print(len(t_test))

#@title Cubic Spline - Not a Knot

train_cubicspline_k = CubicSpline(t_train, w_train)

plt.plot(t_interp, -w_interp, '-', label = 'Puntos originales')
plt.plot(t_train, -train_cubicspline_k(t_train), '.', label = 'Puntos de entrenamiento')
plt.plot(t_test, -w_test, '.', label = 'Puntos de prueba')
plt.title('Cubic Spline not a knot')
plt.legend()
plt.show()

#Errores para Cubic Spline K

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_cubick= train_cubicspline_k(t_test)

# ===== 2) Errores punto a punto =====
ae_cubick = np.abs(y_hat_cubick - w_test)  # Absolute Error (AE)
se_cubick = (y_hat_cubick - w_test)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_cubick = float(np.mean(ae_cubick))
MSE_cubick = float(np.mean(se_cubick))

print(f"Cubic spline → MAE={MAE_cubick:.6e} | MSE={MSE_cubick:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test, ae_cubick, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Cubic spline not a knot - Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test, se_cubick, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Cubic spline not a knot - Error Cuadrático en TEST")
plt.show()

#@title Cubic Spline - Natural

train_cubicspline_n = CubicSpline(t_train, w_train, bc_type="natural")

plt.plot(t_interp, -w_interp, '-', label = 'Puntos originales')
plt.plot(t_train, -train_cubicspline_n(t_train), '.', label = 'Puntos de entrenamiento')
plt.plot(t_test, -w_test, '.', label = 'Puntos de prueba')
plt.title('Cubic Spline natural')
plt.legend()
plt.show()

#Errores para Cubic Spline Natural

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_cubic= train_cubicspline_n(t_test)

# ===== 2) Errores punto a punto =====
ae_cubic = np.abs(y_hat_cubic - w_test)  # Absolute Error (AE)
se_cubic = (y_hat_cubic - w_test)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_cubic = float(np.mean(ae_cubic))
MSE_cubic = float(np.mean(se_cubic))

print(f"Cubic spline → MAE={MAE_cubic:.6e} | MSE={MSE_cubic:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test, ae_cubic, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Cubic spline Natural- Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test, se_cubic, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Cubic spline Natural - Error Cuadrático en TEST")
plt.show()

#@title PchipInterpolator

train_pchip = PchipInterpolator(t_train, w_train)

plt.plot(t_interp, -w_interp, '-', label = 'Puntos originales')
plt.plot(t_train, -train_pchip(t_train), '.', label = 'Puntos de entrenamiento')
plt.plot(t_test, -w_test, '.', label = 'Puntos de prueba')
plt.title('PchipInterpolator')
plt.legend()
plt.show()

#Errores para PchipInterpolator

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_interp= train_pchip(t_test)

# ===== 2) Errores punto a punto =====
ae_interp = np.abs(y_hat_interp - w_test)  # Absolute Error (AE)
se_interp = (y_hat_interp - w_test)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_interp = float(np.mean(ae_interp))
MSE_interp = float(np.mean(se_interp))

print(f"Cubic spline → MAE={MAE_interp:.6e} | MSE={MSE_interp:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test, ae_interp, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Cubic spline not a knot - Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test, se_interp, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Cubic spline not a knot - Error Cuadrático en TEST")
plt.show()

#@title Lagrange

t_train_lagrange = t_interp[::550]
w_train_lagrange = w_interp[::550]
t_test_lagrange = t_interp[275::550]
w_test_lagrange = w_interp[275::550]

train_lagrange = lagrange(t_train_lagrange, w_train_lagrange)

plt.plot(t_interp, -w_interp, '-', label = 'Puntos originales')
plt.plot(t_train_lagrange, -w_train_lagrange, '.', label = 'Puntos de entrenamiento')
plt.plot(t_test_lagrange, -w_test_lagrange, '.', label = 'Puntos de prueba')
plt.title('Lagrange')
plt.legend()
plt.show()

#Errores para Lagrange


# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_lagrange = train_lagrange(t_test_lagrange)

# ===== 2) Errores punto a punto =====
ae_lagrange = np.abs(y_hat_lagrange - w_test_lagrange)  # Absolute Error (AE)
se_lagrange = (y_hat_lagrange - w_test_lagrange)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_lagrange = float(np.mean(ae_lagrange))
MSE_lagrange = float(np.mean(se_lagrange))

print(f"Lagrange → MAE={MAE_lagrange:.6e} | MSE={MSE_lagrange:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test_lagrange, ae_lagrange, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Lagrange - Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test_lagrange, se_lagrange, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Lagrange - Error Cuadrático en TEST")
plt.show()

#@title Grupos de Entrenamiento y de Prueba con mas datos

t_train2 = t_interp[::2]
w_train2 = w_interp[::2]
t_test2= t_interp[1::2]
w_test2 = w_interp[1::2]

#Errores para Cubic Spline K

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_cubick= train_cubicspline_k(t_test2)

# ===== 2) Errores punto a punto =====
ae_cubick = np.abs(y_hat_cubick - w_test2)  # Absolute Error (AE)
se_cubick = (y_hat_cubick - w_test2)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_cubick = float(np.mean(ae_cubick))
MSE_cubick = float(np.mean(se_cubick))

print(f"Cubic spline → MAE={MAE_cubick:.6e} | MSE={MSE_cubick:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test2, ae_cubick, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Cubic spline not a knot - Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test2, se_cubick, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Cubic spline not a knot - Error Cuadrático en TEST")
plt.show()

#Errores para Cubic Spline Natural

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_cubic= train_cubicspline_n(t_test2)

# ===== 2) Errores punto a punto =====
ae_cubic = np.abs(y_hat_cubic - w_test2)  # Absolute Error (AE)
se_cubic = (y_hat_cubic - w_test2)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_cubic = float(np.mean(ae_cubic))
MSE_cubic = float(np.mean(se_cubic))

print(f"Cubic spline → MAE={MAE_cubic:.6e} | MSE={MSE_cubic:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test2, ae_cubic, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("Cubic spline Natural- Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test2, se_cubic, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("Cubic spline Natural - Error Cuadrático en TEST")
plt.show()

#Errores para PchipInterpolator

# ===== 1) Predicciones en el conjunto de prueba =====
y_hat_interp= train_pchip(t_test2)

# ===== 2) Errores punto a punto =====
ae_interp = np.abs(y_hat_interp - w_test2)  # Absolute Error (AE)
se_interp = (y_hat_interp - w_test2)**2     # Squared Error (SE)

# ===== 3) Métricas globales =====
MAE_interp = float(np.mean(ae_interp))
MSE_interp = float(np.mean(se_interp))

print(f"Cubic spline → MAE={MAE_interp:.6e} | MSE={MSE_interp:.6e}")

# ===== 4) Gráficas de los errores =====
import matplotlib.pyplot as plt

plt.figure()
plt.plot(t_test2, ae_interp, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("AE = |y - y_hat|")
plt.title("PchipInterpolator - Error Absoluto en TEST")
plt.show()

plt.figure()
plt.plot(t_test2, se_interp, "o", ms=3)
plt.xlabel("t (TEST)")
plt.ylabel("SE = (y - y_hat)^2")
plt.title("PchipInterpolator - Error Cuadrático en TEST")
plt.show()